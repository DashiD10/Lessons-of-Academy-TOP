# 1. Сеты. Хеширование и рандом на практике (орел решка)
# 2. Методы сетов (анализ коллекции фильмов)
# 3. Знакомство со словарями
 
"""
 
 
 
 
 
# # PRACTICE Орел Решка на сетах
# """
# Подкидываем монетку через while и сеты
# 1. Сделайте переменную счетчик (опционально, это может быть пользовательским вводом - сколько хотите раз подкинуть монетку)
# 2. Сделайте цикл while пока счетчик меньше 10
# 3. Внутри цикла сделайте сет с 2 строками, орел, решка
# 4. Сделайте принт сет.pop и счетчик + 1
 
# Давайте разберем полную картину:
 
# В Python строковые литералы (строки в кавычках) интернируются - это значит, что Python повторно использует уже созданные строки вместо создания новых копий. Когда вы пишете {'орел', 'решка'} много раз в цикле, Python не создает новые строки каждый раз, а использует ссылки на уже существующие.
 
# Представьте это как колоду карт:
 
# У вас есть две карты: Туз ♠️ (орел) и Король ♠️ (решка)
# Каждый раунд вы:
# Берете КОПИИ этих же самых карт (но это те же самые карты, просто новая колода)
# Раскладываете их по тем же правилам (хеширование)
# Туз всегда ложится слева, потому что его "вес" (хеш) меньше
# Король всегда справа
# Берете левую карту (pop берет первый элемент по хешу)
# И получаете каждый раз Туза!
 
# """

# coin_set = {"орел", "решка"}
# print(coin_set.pop())


# import random
# THROUGHOUT = 10
# coin_list = ["орел", "решка"]   

# for i in range(THROUGHOUT):
#     coin = random.choice(coin_list)
#     if coin == "орел":
#         eagle_count += 1
#     else:
#         tails_count += 1
#     print(coin)
#     print(f"Орел выпал {eagle_count} раз", f"Решка выпала {tails_count} раз")



# a = 2.5
# print(hash(a))

# b = 4
# print(hash(b))

# c = "dsfhaljksdhgfaerwh#"
# print(hash(c))


# Методы сетов
"""
add(item) - добавляет элемент в множество
clear() - удаляет все элементы из множества
copy() - возвращает копию множества
difference(set) - или оператор - возвращает разницу между множествами
difference_update(set) - или оператор -= удаляет элементы из множества, которые есть во втором множестве
discard(item) - удаляет элемент из множества, если он там есть
intersection(set) - или оператор & возвращает пересечение множеств
intersection_update(set) - или оператор &= обновляет множество, оставляя только элементы, которые есть в обоих множествах
isdisjoint(set) - возвращает True, если множества не имеют общих элементов
issubset(set) - возвращает True, если все элементы множества содержатся во втором множестве
issuperset(set) - возвращает True, если все элементы второго множества содержатся в первом множестве
symmetric_difference(set) - или оператор ^ возвращает симметричную разность множеств (элементы, которые есть только в одном из множеств)
symmetric_difference_update(set) - или оператор ^= обновляет множество, оставляя только элементы, которые есть только в одном из множеств
union(set) - или оператор | возвращает объединение множеств
update(set) - или оператор |= обновляет множество, добавляя элементы из другого множества
"""
 
new_set = {}  # это не сет, это словарь
new_set = set()

new_set.add("хлеб")
new_set.add("хлеб")
new_set.add("хлеб")
new_set.add("коньяк")

print(new_set)


new_set.discard("коньяк")
print(new_set)


my _movies = {"Терминатор", "Матрица", "Начало", "Гладиатор", "Бойцовский клуб", "Престиж", "Интерстеллар"}
wife_movies = {"Титаник", "Дневник памяти", "Престиж", "Интерстеллар", "Ла-Ла Ленд", "Гордость и предубеждение"}

print(my_movies - wife_movies)


person_dict = {
    "name": "Никита",
    "age": 20,
    "is_student": True,
}

person_dict["age"] = 21


# PRACTICE - проверка на палиндром резульат в Словарь
words = ['мадам', 'топот', 'test']
palindromes = {}
"""
Напишите программу, которая находит все палиндромы в списке и сохраняет их в словаре, где ключом будет исходное слово, а значением - bool.
"""

for word in words:
    palinddromes[word] = word == word [::-1]

palindromes = {word: word == word[::-1] for word in words}


"""
len(dict) - возвращает количество элементов в словаре
for - итерация по ключам словаря
in - проверяет, есть ли ключ в словаре
get(key, default=None) - возвращает значение ключа, если ключ существует, иначе возвращает default
items() - возвращает пары ключ-значение в виде списка кортежей
keys() - возвращает список ключей
values() - возвращает список значений
update(other) - обновляет словарь, добавляя пары ключ-значение из other
clear() - удаляет все элементы из словаря
copy() - возвращает копию словаря
fromkeys(iterable, value=None) - возвращает словарь с ключами из iterable и значением value
pop(key, default=None) - удаляет ключ и возвращает значение, если ключ существует, иначе возвращает default
popitem() - удаляет и возвращает последнюю пару ключ-значение
setdefault - возвращает значение ключа, если ключ существует, иначе добавляет ключ с значением default
"""